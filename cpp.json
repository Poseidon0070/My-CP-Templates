{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"boilerplate": {
		"prefix": "bp1",
		"body": [
			"#include <bits/stdc++.h>",
			"typedef long long ll;",
			"#define vi     vector <int>",
			"#define vll    vector <long long>",
			"#define vs     vector <string>",
			"#define vc     vector <char>",
			"#define PII    pair<int,int>",	
			"#define MII    map<int,int>",
			"#define UMII   unordered_map<int,int>",
			"#define sz(v)  (int)v.size()",
			"#define all(v) v.begin(),v.end()",
			"#define ff     first ",
			"#define ss     second ",
			"#define int    long long",
			"#define endl   \"\\n\"",
			"#define TxtIO  freopen(\"input.txt\",\"r\",stdin); \\",
							"\t\t\t   freopen(\"output.txt\",\"w\",stdout);",
			"using namespace std;",
			"const int  M  = 1e9+7;",
			"const int  N  = 1e5+7;",
			"signed main()",
			"{",
				"\tios_base::sync_with_stdio(false);",
				"\tcin.tie(0);",
				"\tcout.tie(0);",
				"\tint t; cin >> t;",
				"\twhile(t--){",
				"\t\t$0",
				"\t}",
			"\treturn 0;",
			"}",
		],
		"description": "Log output to console"
	},
	"PBDS": {
		"prefix": "PBDS",
		"body": [
			"#include <bits/stdc++.h>",
			"#include<ext/pb_ds/tree_policy.hpp>",
			"#include<ext/pb_ds/assoc_container.hpp>",
			"typedef long long ll;",
			"#define vi     vector <int>",
			"#define vll    vector <long long>",
			"#define vs     vector <string>",
			"#define vc     vector <char>",
			"#define PII    pair<int,int>",	
			"#define MII    map<int,int>",
			"#define UMII   unordered_map<int,int>",
			"#define sz(v)  (int)v.size()",
			"#define all(v) v.begin(),v.end()",
			"#define ff     first ",
			"#define ss     second ",
			"#define int    long long",
			"#define endl   \"\\n\"",
			"#define TxtIO   freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);",
			"using namespace __gnu_pbds;",
			"using namespace std;",
			"template<class T> using PBDS = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;",
			"//*st.find_by_order(index) //st.order_of_key(value)",
			"//Other functions : st.lower_bound(),st.upper_bound(), st.erase() all works same!!!!",
			"const int  M  = 1e9+7;",
			"const int  N  = 1e5+7;",
			"signed main()",
			"{",
				"\tios_base::sync_with_stdio(false);",
				"\tcin.tie(0);",
				"\tcout.tie(0);",
				"\tint t; cin >> t;",
				"\twhile(t--){",
				"\t\t$0",
				"\t}",
			"\treturn 0;",
			"}",
		],
		"description": "Log output to console"
	},
	"Vector_display": {
		"prefix": "display",
		"body": [
			"for(int i{};i<v.size();i++) cout << v[i] << \" \\n\"[i == v.size()-1];"
		],
		"description": "Log output to console"
	},
	"Set_display": {
		"prefix": "sdisplay",
		"body": [
			"for (auto &i:st$0){",
			"\tcout << i << \" \";",
			"}cout << \"\\n\";",
		],
		"description": "Log output to console"
	},
	"2D_display": {
		"prefix": "2ddsp",
		"body": [
			"for(int i{};i<r;i++){",
				"\tfor(int j{};j<c;j++){",
					"\t\tcout << v[i][j] << \" \";",
				"\t}",
				"\tcout << endl;",
			"}" ,   
		],
		"description": "Log output to console"
	},
	"Map_display": {
		"prefix": "mdsp",
		"body": [
			"for (auto &i:mp$0){",
			"\tcout << i.ff <<\" \"<< i.ss << \"\\n\";",
			"}",
		],
		"description": "Log output to console"
	},
	"Least_Frequent": {
		"prefix": "l_f",
		"body": [
			"int lf(vi v){",
				"\tunordered_map <int,int> m;",
				"\tfor(int i{};i<v.size();i++){",
					"\t\tm[v[i]]++;",
				"\t}",
				"\tint me{}; ll c{LLONG_MAX};",
				"\tfor(auto i:m){",
					"\t\tif(i.second<c){",
						"\t\tme=i.first;",
						"\t\tc=i.second;",
					"\t}",
				"\t}",
				"\treturn me;",
			"}",
		],
		"description": "Log output to console"
	},
	"Most_Frequent": {
		"prefix": "m_f",
		"body": [
			"int mf(vi &v){",
				"\tunordered_map <int,int> m;",
				"\tfor(int i{};i<v.size();i++) m[v[i]]++;",
				"\tint ans{}; int c{-1};",
				"\tfor(auto i:m){",
					"\t\tif(i.second>c){",
						"\t\t\tans=i.first;",
						"\t\t\tc=i.second;",
					"\t\t}",
				"\t}",
				"\treturn ans;",
			"}",
		],
		"description": "Log output to console"
	},
	"Boiler Plate 2": {
		"prefix": "bp2",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"int main()",
			"{",
				"\t$0",
			"\treturn 0;",
			"}",
		],
		"description": "Log output to console"
	},
	"is_prime": {
		"prefix": "is_prime",
		"body": [
			"bool isPrime(ll n){",
			    "\tif (n <= 1)return false; if (n <= 3)return true; if (n % 2 == 0 || n % 3 == 0)return false;",
			    "\tfor (int i = 5; i * i <= n; i = i + 6)if (n % i == 0 || n % (i + 2) == 0)return false;",
			    "\treturn true;",
			"}",
		],
		"description": "Log output to console"
	},
	"charinttoint": {
		"prefix": "itoi",
		"body": [
			"int itoi(char c){",
				"\treturn (int)(c - '0');",
			"}",
		],
		"description": "Log output to console"
	},
	"chartoint": {
		"prefix": "ctoi",
		"body": [
			"int ctoi(char c){",
				"\treturn (int)(c - 'a');",
			"}",
		],
		"description": "Log output to console"
	},
	"cin": {
		"prefix": "frin",
		"body": [
			"for(int i{};i<n;i++){",
				"\tint temp; cin >> temp;",
				"\tv.push_back(temp);",
			"}",
		],
		"description": "Log output to console"
	},
	"kcin": {
		"prefix": "kfrin",
		"body": [
			"for(auto &temp:v) cin >> temp;",
		],
		"description": "Log output to console"
	},
	"LCM": {
		"prefix": "lcm",
		"body": [
			"ll gcd(ll a, ll b) {if (b == 0)return a; return gcd(b, a % b);}",
			"ll lcm(ll a, ll b) {return (a / gcd(a, b) * b);}",
		],
		"description": "Log output to console"
	},
	"PERFECT SQUARE": {
		"prefix": "is_perfect_square",
		"body": [
			"bool isPerfectSquare(ll x) {if (x >= 0) {ll sr = sqrt(x); return (sr * sr == x);} return false;}",
		],
		"description": "Log output to console"
	},
	"Print_Binary": {
		"prefix": "print_binary",
		"body": [
			"void print_binary(int n){",
				"\tfor(int i{10};i>=0;i--){",
					"\t\tcout << ((n >> i) & 1);",
				"\t}cout << \"\\n\";",
			"}",
		],
		"description": "Log output to console"
	},
	"LOG": {
		"prefix": "Log",
		"body": [
			"int Log(int n,int base){",
				"\tif(n < base){",
					"\t\treturn 0;",
				"\t}else{",
					"\t\treturn 1+Log(n/base,base);",
				"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	"PALINDROME": {
		"prefix": "is_palindrome",
		"body": [
			"bool is_palindrome(string &s){",
				"\tint n = sz(s)/2;",
				"\tfor(int i{};i<n;i++){",
					"\t\tif(s[i]!=s[n-i-1]){",
						"\t\t\treturn false;",
					"\t\t}",
				"\t}",
				"\treturn true;",
			"}",
		],
		"description": "Log output to console"
	},
	"BP3": {
		"prefix": "bp3",
		"body": [
			"#include <bits/stdc++.h>",
			"typedef long long ll;",
			"#define sz(v)  v.size()",
			"#define vi     vector <int>",
			"#define vs     vector <string>",
			"using namespace std;",
			"int main()",
			"{",
			"\t$0",
				"\treturn 0;",
			"}"	,		
		],
		"description": "Log output to console"
	},
	"INT_DIF": {
		"prefix": "int_diff",
		"body": [
			"bool is_bigger(string &s1,string &s2){",
				"\tif(sz(s1) > sz(s2)){",
					"\t\treturn true;",
				"\t}else if(sz(s1) < sz(s2)){",
				"\treturn false;",
				"\t}",
				"\tfor(int i{};i<sz(s1);i++){",
					"\t\tif(s1[i] > s2[i]){",
						"\t\t\treturn true;",
					"\t\t}else if(s1[i] < s2[i]){",
						"\t\t\treturn false;",
					"\t\t}",
				"\t}",
				"\treturn false;",
			"}",
			"string int_diff(string &s1,string &s2){",
				"\tif(!is_bigger(s1,s2)){",
					"\t\tswap(s1,s2);",
				"\t}",
				"\treverse(all(s1));",
				"\treverse(all(s2));",
				"\tstring s3;",
				"\tint c{};int sub{};",
				"\tfor(int i{};i<sz(s2);i++){",
					"\t\tsub = (s1[i]-'0') - (s2[i]-'0') - c;",
					"\t\tif(sub < 0){",
						"\t\t\tc = 1;",
						"\t\t\tsub+=10;",
					"\t\t}else{",
						"\t\t\tc = 0;",
					"\t\t}",
					"\t\ts3.push_back(sub+'0');  ",
				"\t}",
				"\tfor(int i{int(sz(s2))};i<sz(s1);i++){",
					"\t\tsub = (s1[i]-'0') - c;",
					"\t\tif(sub < 0){",
						"\t\t\tc = 1;",
						"\t\t\tsub+=10;",
					"\t\t}else{",
						"\t\t\tc = 0;",
					"\t\t}",
					"\t\ts3.push_back(sub+'0');",
				"\t}",
				"\treverse(all(s3));",
				"\treturn s3;",
			"}",
		],
		"description": "Log output to console"
	},
	"INT_SUM": {
		"prefix": "int_sum",
		"body": [
			"bool is_bigger(string &s1,string &s2){",
				"\tif(sz(s1) > sz(s2)){",
					"\t\treturn true;",
				"\t}else if(sz(s1) < sz(s2)){",
				"\treturn false;",
				"\t}",
				"\tfor(int i{};i<sz(s1);i++){",
					"\t\tif(s1[i] > s2[i]){",
						"\t\t\treturn true;",
					"\t\t}else if(s1[i] < s2[i]){",
						"\t\t\treturn false;",
					"\t\t}",
				"\t}",
				"\treturn false;",
			"}",
			"string int_sum(string &s1,string &s2){",
				"\tif(!is_bigger(s1,s2)){",
					"\t\tswap(s1,s2);",
				"\t}",
				"\treverse(all(s1));",
				"\treverse(all(s2));",
				"\tstring s3;",
				"\tint c{};int sum{};",
				"\tfor(int i{};i<sz(s2);i++){",
					"\t\tsum = (s1[i]-'0') + (s2[i]-'0') + c;",
					"\t\tif(sum > 9){",
						"\t\t\tc = 1;",
						"\t\t\tsum%=10;",
					"\t\t}else{",
						"\t\t\tc = 0;",
					"\t\t}",
					"\t\ts3.push_back(sum+'0');  ",
				"\t}",
				"\tfor(int i{int(sz(s2))};i<sz(s1);i++){",
					"\t\tsum = (s1[i]-'0') + c;",
					"\t\tif(sum > 9){",
						"\t\t\tc = 1;",
						"\t\t\tsum%=10;",
					"\t\t}else{",
						"\t\t\tc = 0;",
					"\t\t}",
					"\t\ts3.push_back(sum+'0');",
				"\t}",
				"\tif(c == 1){",
					"\t\ts3.push_back(1+'0');",
				"\t}",
				"\treverse(all(s3));",
				"\treturn s3;",
			"}",
		],
		"description": "Log output to console"
	},
	"2d_input": {
		"prefix": "2dins",
		"body": [
			"for(int i{};i<r;i++){",
				"\tfor(int j{};j<c;j++){",
					"\t\tcin >> v[i][j];",
				"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	"POWER": {
		"prefix": "binpow",
		"body": [
			"int binpow(int a,int b){",
				"\tif(b == 0) return 1;",
				"\tint p = binpow(a,b/2)%M;",
				"\tif(b&1) return (((p*p)%M)*a)%M; ",
				"\treturn (p*p)%M;",
			"}",
		],
		"description": "Log output to console"
	},
	"Prime_Seive": {
		"prefix": "prime_seive",
		"body": [
			"void prime_seive(vector<int> &v){",
				"\tfor(int i{3};i<=1000005;i+=2){",
					"\t\tv[i] = 1;",
				"\t}",
				"\tfor(int i{3};i<=1000005;i+=2){",
					"\t\tif(v[i]){",
						"\t\t\tfor(int j{i*i};j<=1000005;j+=i){",
							"\t\t\t\tv[j] = 0;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\tv[2] = 1;",
				"\tv[0] = v[1] = 0;",
			"}",
		],
		"description": "Log output to console"
	},
	"Seive": {
		"prefix": "seive",
		"body": [
			"//Vector to be initialized with 1",
			"void seive(vector<int> &v,int x){",      
				"\tv[0] = v[1] = 0;",
				"\tv[2] = 1;",
				"\tfor(int i{2};i<x;i++){",
					"\t\tif(v[i]){",
						"\t\t\t//Primes can be pushed to other vector",
						"\t\t\tfor(int j{i*i};j<x;j+=i){",
							"\t\t\t\tv[j] = 0;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	"Modulus": {
		"prefix": "modop",
		"body": [
			"int mod (int x){return (x%M + M)%M;}",
			"int add(int a,int b){return mod(mod(a)+mod(b));}",
			"int mul(int a,int b){return mod(mod(a)*mod(b));}",
		],
		"description": "Log output to console"
	},
	"Combinatorics": {
		"prefix": "combinatorics",
		"body": [
			"int factorial(int n) {",
				"\tint f = 1;",
				"\tfor (int i = 2; i <= n; i++)",
					"\t\tf = f * i;",
				"\treturn f;",
			"}",
			"int gcdEx(int a, int b, int* x, int* y) {",
				"\t// Base Case",
				"\tif (a == 0) {",
					"\t\t*x = 0, *y = 1;",
					"\t\treturn b;",
				"\t}",
				"\tint x1, y1;",
				"\tint gcd = gcdEx(b % a, a, &x1, &y1);",
				"\t*x = y1 - (b / a) * x1;",
				"\t*y = x1;",
				"\treturn gcd;",
			"}",
			
			"int inv(int A) {",
				"\tint x, y;",
				"\tint g = gcdEx(A, M, &x, &y);",
				"\tint res = (x % M + M) % M;",
				"\treturn res;",
			"}",
			"int nCr(int a,int b){",
				"\tif (b < 0 or a < 0) return 0;",
				"\treturn (((factorial(a) * inv(factorial(b)))%M * inv(factorial(a - b)))%M + M)%M;",
			"}",
			"int nPr(int n, int r) {",
				"\treturn factorial(n) / factorial(n - r);",
			"}",
		],
		"description": "Log output to console"
	},
	"chotu": {
		"prefix": "chotu",
		"body": [
			"int chotu(vi &v,int x){",
				"\tint low = 0;",
				"\tint high = sz(v)-1;",
				"\tint ans{-1};",
				"\twhile(low <= high){",
					"\t\tint mid = low+(high-low)/2;",
					"\t\tif(v[mid] <= x){",
						"\t\t\tans = mid;",
						"\t\t\tlow = mid + 1;",
					"\t\t}else{",
						"\t\t\thigh = mid - 1;",
					"\t\t}",
				"\t}",
				"\treturn ans;",
			"}",
		],
		"description": "Log output to console"
	},
	"ceil": {
		"prefix": "ceiln",
		"body": [
			"int ceiln(int a,int b){",
				"\treturn (a+b-1)/b;",
			"}",
		], 
		"description": "Log output to console"
	},
	"PrimeFactor": {
		"prefix": "prime_factor",
		"body": [
			"void factor(vi &v,int n,map<int,int> &mp){",
				"\tint i{};",
				"\tint k = p[i];",
				"\twhile(k*k <= n){",
					"\t\tif(n%k == 0){",
						"\t\t\tv.push_back(k);",
						"\t\t\twhile(n%k == 0){",
						"\t\t\t\tmp[k]++;",
							"\t\t\t\tn = n/k;",
						"\t\t\t}",
					"\t\t}",
					"\t\ti++;",
					"\t\tk = p[i];",
				"\t}",
				"\tif(n != 1){",
					"\t\tv.push_back(n);",
					"\t\tmp[n]++;",
				"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	"BinaryTree": {
		"prefix": "bintree",
		"body": [
			"struct node{",
				"\tint key;",
				"\tnode *left;",
				"\tnode *right;",
				"\tnode(int x){",
					"\t\tkey = x;",
					"\t\tleft = right = nullptr;",
				"\t}",
			"};",
		],
		"description": "Log output to console"
	},
	"InorderTraversal": {
		"prefix": "inorder",
		"body": [
			"void inorder(node *a){",
				"\tif(a != nullptr){",
					"\t\tinorder(a->left);",
					"\t\tcout << a->key << \" \";",
					"\t\tinorder(a->right);",
				"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	"PreorderTraversal": {
		"prefix": "preorder",
		"body": [
			"void preorder(node *a){",
				"\tif(a != nullptr){",
					"\t\tcout << a->key << \" \";",
					"\t\tpreorder(a->left);",
					"\t\tpreorder(a->right);",
				"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	"PostorderTraversal": {
		"prefix": "postorder",
		"body": [
			"void postorder(node *a){",
				"\tif(a != nullptr){",
					"\t\tpostorder(a->left);",
					"\t\tpostorder(a->right);",
					"\t\tcout << a->key << \" \";",
				"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	"Level_print": {
		"prefix": "levelprint",
		"body": [
			"void level_print(node *root){",
				"\tif(root == nullptr) return ;",
				"\tqueue<node *> q;",
				"\tq.push(root);",
				"\twhile(!q.empty()){",
					"\t\tnode *curr = q.front();",
					"\t\tq.pop();",
					"\t\tcout << curr->key << \" \";",
					"\t\tif(curr->left != nullptr){",
						"\t\t\tq.push(curr->left);",
					"\t\t}",
					"\t\tif(curr->right != nullptr){",
						"\t\t\tq.push(curr->right);",
					"\t\t}",
				"\t}",
			"}",
		],
		"description": "Log output to console"
	},
	"here?": {
		"prefix": "here",
		"body": [
			"cout << \"HERE!\" << \"\\n\";",
		],
		"description": "Log output to console"
	},
	"YES": {
		"prefix": "yes",
		"body": [
			"cout << \"YES\" << \"\\n\";"
		],
		"description": "Log output to console"
	},
	"NO": {
		"prefix": "noo",
		"body": [
			"cout << \"NO\" << \"\\n\";"
		],
		"description": "Log output to console"
	},
	"LINKED_LIST": {
		"prefix": "linked_list",
		"body": [
			"struct node{",
			"\tint key;",
			"\tnode *next = nullptr;",
			"\tnode(int a){",
			"\t\tthis->key = a;",
			"\t\tthis->next = NULL;",
			"\t}",
			"};",
			"void displayll(node *&head){",
			"\tnode *curr = head;",
			"\twhile(curr != nullptr){",
			"\t\tcout << curr->key << \" \";",
			"\t\tcurr = curr->next;",
			"\t}",
			"}",
			"node *ins_at_beg(node *head,int data){",
			"\tnode *temp = new node(data);",
			"\ttemp->next = head;",
			"\treturn temp;",
			"}",
			"node *ins_at_end(node *head,int data){",
			"node *temp = new node(data);",
				"if(head == nullptr) return temp;",
				"node *curr = head;",
				"while(curr->next != nullptr){",
				"curr = curr->next;",
				"}",
				"curr->next = temp;",
				"return head;",
				"}",
				"node *del_from_beg(node *head){",
				"\tif(head == nullptr) return nullptr;",
				"\tnode *temp = head->next;",
				"\tdelete(head);",
				"\treturn temp;",
				"}",
				"node *del_from_end(node *head){",
				"\tif(head == nullptr) return nullptr;",
				"\tif(head->next == nullptr){",
				"  \t\tdelete(head);",
				"  \t\treturn nullptr;",
				"\t}",
				"\tnode *curr = head;",
				"\twhile(curr->next->next != nullptr) curr = curr->next;",
				"\tdelete(curr->next);",
				"\tcurr->next = nullptr;",
				"\treturn head;",
				"}",
			],
			"description": "Log output to console"
		},
		"ROTATE": {
			"prefix": "rotate",
			"body": [
				"void left_rotate(vi &v,int times){",
					"\ttimes = times % sz(v);",
					"\treverse(v.begin(),v.begin()+times);",
					"\treverse(v.begin()+times,v.end());",
					"\treverse(v.begin(),v.end());",
				"}",
				"void right_rotate(vi &v,int times){",
					"\ttimes = times % sz(v);",
					"\treverse(v.begin(),v.end());",
					"\treverse(v.begin(),v.begin()+times);",
					"\treverse(v.begin()+times,v.end());",
				"}",
			],
			"description": "Log output to console"
		},
		"CheckEdge": {
			"prefix": "ChechEdge",
			"body": [
				"// n - row, m - column, v - matrix",
				"bool chechEdge(){",
					"\tif(j-1 >= 0 && v[i][j-1]) ",
					"\tif(i-1 >= 0 && j-1 >= 0 && v[i-1][j-1]) ",
					"\tif(i-1 >= 0 && v[i-1][j]) ",
					"\tif(i-1 >= 0 && j+1 < m && v[i-1][j+1]) ",
					"\tif(j+1 < m && v[i][j+1]) ",
					"\tif(i+1 < n && j+1 < m && v[i+1][j+1]) ",
					"\tif(i+1 < n && v[i+1][j]) ",
					"\tif(i+1 < n && j-1 >= 0 && v[i+1][j-1]) ",
				"}",
			],
			"description": "Log output to console"
		},
		"Graphs": {
			"prefix": "Graphs",
			"body": [
				"void addEdge(vector<vector<int>> &adj,int u,int v){",
				"\tadj[u].push_back(v);",
				"\tadj[v].push_back(u);",
				"}",
				"void printGraph(vector<vector<int>> &adj,int n){",
				"\tfor(int i{};i<n;i++){",
				"\t\tfor(auto &j:adj[i]){",
				"\t\t\tcout << j << \" \";",
				"\t\t}cout << \"\\n\";",
				"\t}",
				"}",
				"void BFS(vector<vector<int>> adj,int n,int s){",
				"\tvector<bool> vis(n+1,0);",
				"\tqueue<int> q;",
				"\tq.push(s);",
				"\tvis[s] = 1;",
				"\twhile(!q.empty()){",
				"\t\tint u = q.front();",
				"\t\tq.pop();",
				"\t\tcout << u << \" \";",
				"\t\tfor(auto &j:adj[u]){",
				"\t\t\tif(vis[j] == 0){",
				"\t\t\t\tvis[j] = 1;",
				"\t\t\t\tq.push(j);",
				"\t\t\t}",
				"\t\t}",
				"\t}",
				"}",
				"void BFSDisH(vector<vector<int>> &adj,int n,int s,vector<bool> &vis){",
				"\tqueue<int> q;",
				"\tq.push(s);",
				"\tvis[s] = 1;",
				"\twhile(!q.empty()){",
				"\t\tint u = q.front();",
				"\t\tq.pop();",
				"\t\tcout << u << \" \";",
				"\t\tfor(auto &j:adj[u]){",
				"\t\t\tif(vis[j] == 0){",
				"\t\t\t\tvis[j] = 1;",
				"\t\t\t\tq.push(j);",
				"\t\t\t}",
				"\t\t}",
				"\t}",
				"}",
				"void BFSDis(vector<vector<int>> &adj,int n,int s){",
				"\tvector<bool> vis(n+1,0);",
				"\tfor(int i{};i<n;i++){",
				"\t\tif(vis[i] == 0){",
				"\t\t\tBFSDisH(adj,n,i,vis);",
				"\t\t}",
				"\t}",
				"}",
				"void DFSDisH(vector<vector<int>> &adj,int n,int s,vector<int> &vis){",
				"\tvis[s] = 1;",
				"\tcout << s << \" \";",
				"\tfor(auto &j:adj[s]){",
				"\t\tif(vis[j] == 0){",
				"\t\t\tDFSDisH(adj,n,j,vis);",
				"\t\t}",
				"\t}",
				"}",
				"void DFSDis(vector<vector<int>> &adj,int n){",
				"\tvector<int> vis(n+1,0);",
					"\tfor(int i{};i<n;i++){",
					"\t\tif(vis[i] == 0){",
					"\t\t\tDFSDisH(adj,n,i,vis);",
					"\t\t}",
					"\t}",
					"}",
				],
				"description": "Log output to console"
			},
			"DSU": {
				"prefix": "DSU",
				"body": [
					"int find(int x,vector<int> &par){",
						"\tif(par[x] == x) return x;",
						"\tpar[x] = find(par[x],par);",
						"\treturn par[x];  ",
					"}",
					"void merge(int a,int b,vector<int> &par,vector<int> &rank) {",
						"\tint rep_a = find(a,par);",
						"\tint rep_b = find(b,par);",
						"\tif(rep_a == rep_b) return;",
						"\tif(rank[rep_a] > rank[rep_b]) par[rep_b] = rep_a; ",
						"\tif(rank[rep_a] < rank[rep_b]) par[rep_a] = rep_b;",
						"\telse{",
							"\t\tpar[rep_b] = rep_a; ",
							"\t\trank[rep_a]++;",
						"\t}",
					"}",
					"bool isConnected(int x,int y,vector<int> &par,vector<int> &rank){",
						"\tif(find(x,par) == find(y,par)) return 1;",
						"\treturn 0;",
					"}",
				],
				"description": "Log output to console"
			},
			"Edge": {
				"prefix": "graphEdge",
				"body": [
					"class edge{",
						"public:",
							"\tint vtc,nbr,wt;",
							"\tedge(int a,int b,int c){",
								"\t\tthis->vtc = a;",
								"\t\tthis->nbr = b;",
								"\t\tthis->wt = c;",
							"\t}",
						"};",
				],
				"description": "Log output to console"
			},
			"Move1": {
				"prefix": "move1",
				"body": [
					"vector<pair<int,int>> mov = {{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1},{-1,0}};"
				],
				"description": "Log output to console"
			},
			"Move2": {
				"prefix": "move2",
				"body": [
					"vector<pair<int,int>> mov = {{0,1},{1,0},{0,-1},{-1,0}};"
				],
				"description": "Log output to console"
			},
			"issafe": {
				"prefix": "issafe",
				"body": [
					"bool issafe(int i,int j) {return (i >= 0 && j >= 0 && i < n && j < m);}"
				],
				"description": "Log output to console"
			},
			"findMex": {
				"prefix": "findMex",
				"body": [
					"int findMex(vector<int> &v){",
						"\tUMII mp;",
						"\tint n = v.size();",
						"\tfor(int i{};i<n;i++){",
							"\t\tif(i < n) mp[v[i]]++;",
						"\t}",
						"\tint mex = 0;",
						"\twhile(mex < n && mp[mex]) mex++;",
						"\treturn mex;",
					"}",
				],
				"description": "Log output to console"
			},
			"Int_to_Binary": {
				"prefix": "toBinary",
				"body": [
					"string X(int num,int size){",
						"\tstring z(size,'0');",
						"\tfor(int i{};i<size;i++) if(num&(1 << i)) z[size-1-i] = '1';",
						"\treturn z;",
					"}",
				],
				"description": "Log output to console"
			},
			"Sum of Digits": {
				"prefix": "sum_of_digit",
				"body": [
					"int sum_of_digit(int n){",
						"\tint sum{};",
						"\twhile(n){",
							"\t\tsum += n%10; n /= 10;",
						"\t}",
						"\treturn sum;",
					"}",
				],
				"description": "Log output to console"
			},
			"Modulo Inverse": {
				"prefix": "modulo_inverse",
				"body": [
					"long long fact(int n) {",
						"\tlong long result = 1;",
						"\tfor (int i = 1; i <= n; ++i) {",
							"\t\tresult = (result * i) % M;",
						"\t}",
						"\treturn result;",
					"}",
					"",
					"long long modInverse(long long a, long long m) {",
						"\tlong long m0 = m;",
						"\tlong long y = 0, x = 1;",
						"\tif (m == 1) return 1; ",
						"\twhile (a > 1) {",
							"\t\tlong long q = a / m;",
							"\t\tlong long t = m;",
							"\t\tm = a % m, a = t;",
							"\t\tt = y;",
							"\t\ty = x - q * y;",
						"\tx = t;",
						"\t}",
						"\tif (x < 0) x += m0;",
						"\treturn x;",
					"}",
					"",
					"long long factDivisionMod(int a, int b) {",
						"\tlong long numerator = fact(a);", // modify to a if a is already factorial
						"\tlong long denominator = modInverse(b, M); ",
						"\tlong long result = (numerator * denominator) % M;",
						"\treturn result;",
					"}",
				],
				"description": "Log output to console"
			}
			
		}
		